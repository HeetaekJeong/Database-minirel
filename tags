!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALL	./h/catalog.h	60;"	d
ALL_OP	./h/minirel.h	31;"	d
AME_DUPLICATEKEY	./h/am.h	66;"	d
AME_DUPLICATEOPEN	./h/am.h	46;"	d
AME_DUPLICATERECID	./h/am.h	51;"	d
AME_EOF	./h/am.h	40;"	d
AME_FD	./h/am.h	43;"	d
AME_FULLTABLE	./h/am.h	41;"	d
AME_INVALIDATTR	./h/am.h	61;"	d
AME_INVALIDATTRLENGTH	./h/am.h	53;"	d
AME_INVALIDATTRTYPE	./h/am.h	42;"	d
AME_INVALIDOP	./h/am.h	44;"	d
AME_INVALIDPARA	./h/am.h	45;"	d
AME_INVALIDRECORD	./h/am.h	63;"	d
AME_INVALIDSCANDESC	./h/am.h	48;"	d
AME_KEYNOTFOUND	./h/am.h	65;"	d
AME_NOMEM	./h/am.h	62;"	d
AME_OK	./h/am.h	38;"	d
AME_PF	./h/am.h	39;"	d
AME_RECNOTFOUND	./h/am.h	50;"	d
AME_ROOTNULL	./h/am.h	59;"	d
AME_SCANOPEN	./h/am.h	52;"	d
AME_SCANTABLEFULL	./h/am.h	47;"	d
AME_TOOMANYRECSPERKEY	./h/am.h	64;"	d
AME_TREETOODEEP	./h/am.h	60;"	d
AME_UNABLETOSCAN	./h/am.h	49;"	d
AME_UNIX	./h/am.h	58;"	d
AM_ITAB_SIZE	./h/am.h	6;"	d
AM_NERRORS	./h/am.h	33;"	d
ATTRCATNAME	./h/catalog.h	18;"	d
ATTRCAT_NATTRS	./h/catalog.h	52;"	d
ATTRDESCSIZE	./h/catalog.h	51;"	d
ATTRDESCTYPE	./h/catalog.h	/^} ATTRDESCTYPE;$/;"	t	typeref:struct:_attribute_desc
ATTR_DESCR	./h/fe.h	/^} ATTR_DESCR;$/;"	t	typeref:struct:__anon2
ATTR_VAL	./h/fe.h	/^} ATTR_VAL;$/;"	t	typeref:struct:__anon4
BFE_HASHNOTFOUND	./h/bf.h	47;"	d
BFE_HASHPAGEEXIST	./h/bf.h	48;"	d
BFE_INCOMPLETEREAD	./h/bf.h	43;"	d
BFE_INCOMPLETEWRITE	./h/bf.h	42;"	d
BFE_INVALIDTID	./h/bf.h	45;"	d
BFE_MISSDIRTY	./h/bf.h	44;"	d
BFE_MSGERR	./h/bf.h	46;"	d
BFE_NOBUF	./h/bf.h	37;"	d
BFE_NOMEM	./h/bf.h	36;"	d
BFE_OK	./h/bf.h	35;"	d
BFE_PAGEINBUF	./h/bf.h	40;"	d
BFE_PAGENOTINBUF	./h/bf.h	41;"	d
BFE_PAGEPINNED	./h/bf.h	38;"	d
BFE_PAGEUNPINNED	./h/bf.h	39;"	d
BFE_UNIX	./h/bf.h	53;"	d
BF_AllocBuf	./bf/bf.c	/^int BF_AllocBuf(BFreq bq, PFpage **fpage) {$/;"	f
BF_FlushBuf	./bf/bf.c	/^int BF_FlushBuf(int fd) {$/;"	f
BF_GetBuf	./bf/bf.c	/^int BF_GetBuf(BFreq bq, PFpage **fpage) {$/;"	f
BF_HASH_TBL_SIZE	./h/bf.h	16;"	d
BF_Init	./bf/bf.c	/^void BF_Init(void) {$/;"	f
BF_MAX_BUFS	./h/bf.h	11;"	d
BF_NERRORS	./h/bf.h	33;"	d
BF_PrintError	./bf/bf.c	/^void BF_PrintError(const char *s) {$/;"	f
BF_ShowBuf	./bf/bf.c	/^void BF_ShowBuf(void) {$/;"	f
BF_TouchBuf	./bf/bf.c	/^int BF_TouchBuf(BFreq bq) {$/;"	f
BF_UnpinBuf	./bf/bf.c	/^int BF_UnpinBuf(BFreq bq) {$/;"	f
BFhash_entry	./bf/bf_component.h	/^typedef struct BFhash_entry {$/;"	s
BFhash_entry	./bf/bf_component.h	/^} BFhash_entry;$/;"	t	typeref:struct:BFhash_entry
BFpage	./bf/bf_component.h	/^typedef struct BFpage {$/;"	s
BFpage	./bf/bf_component.h	/^} BFpage;$/;"	t	typeref:struct:BFpage
BFreq	./h/minirel.h	/^} BFreq;$/;"	t	typeref:struct:_buffer_request_control
BOOL_TYPE	./h/catalog.h	71;"	d
CC	./am/Makefile	/^CC	= gcc$/;"	m
CC	./bf/Makefile	/^CC	= gcc$/;"	m
CC	./fe/Makefile	/^CC	= gcc$/;"	m
CC	./hf/Makefile	/^CC	= gcc$/;"	m
CC	./pf/Makefile	/^CC	= gcc$/;"	m
CFLAGS	./am/Makefile	/^CFLAGS	= -g -ansi -pedantic$/;"	m
CFLAGS	./bf/Makefile	/^CFLAGS	= -g -ansi -pedantic$/;"	m
CFLAGS	./fe/Makefile	/^CFLAGS	= -g -ansi -pedantic$/;"	m
CFLAGS	./hf/Makefile	/^CFLAGS	= -g -ansi -pedantic$/;"	m
CFLAGS	./pf/Makefile	/^CFLAGS	= -g -ansi -pedantic$/;"	m
EQ_OP	./h/minirel.h	25;"	d
FALSE	./h/minirel.h	/^typedef enum { FALSE = 0, TRUE } bool_t;$/;"	e	enum:__anon1
FD1	./bf/bftest.c	17;"	d	file:
FEE_ALREADYINDEXED	./h/fe.h	119;"	d
FEE_AM	./h/fe.h	155;"	d
FEE_ATTRNAMETOOLONG	./h/fe.h	120;"	d
FEE_CATALOGCHANGE	./h/fe.h	145;"	d
FEE_DUPLATTR	./h/fe.h	121;"	d
FEE_EOF	./h/fe.h	144;"	d
FEE_HF	./h/fe.h	154;"	d
FEE_INCOMPATJOINTYPES	./h/fe.h	122;"	d
FEE_INCORRECTNATTRS	./h/fe.h	123;"	d
FEE_INTERNAL	./h/fe.h	124;"	d
FEE_INVALIDOP	./h/fe.h	150;"	d
FEE_INVALIDSCAN	./h/fe.h	148;"	d
FEE_INVALIDSCANDESC	./h/fe.h	149;"	d
FEE_INVATTRTYPE	./h/fe.h	125;"	d
FEE_INVNBUCKETS	./h/fe.h	126;"	d
FEE_NOMEM	./h/fe.h	143;"	d
FEE_NOSUCHATTR	./h/fe.h	128;"	d
FEE_NOSUCHDB	./h/fe.h	129;"	d
FEE_NOSUCHREL	./h/fe.h	130;"	d
FEE_NOTFROMJOINREL	./h/fe.h	127;"	d
FEE_NOTINDEXED	./h/fe.h	131;"	d
FEE_OK	./h/fe.h	118;"	d
FEE_PARTIAL	./h/fe.h	132;"	d
FEE_PF	./h/fe.h	156;"	d
FEE_PRIMARYINDEX	./h/fe.h	133;"	d
FEE_RELCAT	./h/fe.h	134;"	d
FEE_RELEXISTS	./h/fe.h	135;"	d
FEE_RELNAMETOOLONG	./h/fe.h	136;"	d
FEE_RELNOTSAME	./h/fe.h	142;"	d
FEE_SAMEJOINEDREL	./h/fe.h	137;"	d
FEE_SCANTABLEFULL	./h/fe.h	147;"	d
FEE_SELINTOSRC	./h/fe.h	138;"	d
FEE_STRTOOLONG	./h/fe.h	146;"	d
FEE_THISATTRTWICE	./h/fe.h	139;"	d
FEE_UNIONCOMPAT	./h/fe.h	140;"	d
FEE_UNIX	./h/fe.h	153;"	d
FEE_WRONGVALTYPE	./h/fe.h	141;"	d
FE_NERRORS	./h/fe.h	116;"	d
FILE1	./am/amtest.c	19;"	d	file:
FILE1	./bf/bftest.c	16;"	d	file:
FILE1	./hf/hftest.c	13;"	d	file:
FILE1	./pf/pftest.c	14;"	d	file:
FILE2	./hf/hftest.c	14;"	d	file:
FILE_CREATE_MASK	./bf/bftest.c	11;"	d	file:
FRL	./bf/bf.c	/^static Free_List *FRL;$/;"	v	file:
F_add_free	./bf/bf_component.c	/^int F_add_free(Free_List *FRL, BFpage *bfpage) {$/;"	f
F_remove_free	./bf/bf_component.c	/^BFpage* F_remove_free(Free_List *FRL) {$/;"	f
Free_List	./bf/bf_component.h	/^typedef struct Free_List {    \/* Singly? Liked List. added & removed at the head *\/$/;"	s
Free_List	./bf/bf_component.h	/^} Free_List;$/;"	t	typeref:struct:Free_List
Free_List_Init	./bf/bf_component.c	/^void Free_List_Init(Free_List *FRL, int max_bfpage) {$/;"	f
Free_List_delete	./bf/bf_component.c	/^void Free_List_delete(Free_List *FRL) { \/* JM_edit *\/$/;"	f
GE_OP	./h/minirel.h	29;"	d
GT_OP	./h/minirel.h	27;"	d
HFE_ATTRLENGTH	./h/hf.h	56;"	d
HFE_ATTROFFSET	./h/hf.h	57;"	d
HFE_ATTRTYPE	./h/hf.h	55;"	d
HFE_EOF	./h/hf.h	49;"	d
HFE_FD	./h/hf.h	46;"	d
HFE_FILE	./h/hf.h	59;"	d
HFE_FILENOTOPEN	./h/hf.h	53;"	d
HFE_FILEOPEN	./h/hf.h	51;"	d
HFE_FTABFULL	./h/hf.h	44;"	d
HFE_INTERNAL	./h/hf.h	60;"	d
HFE_INVALIDRECORD	./h/hf.h	48;"	d
HFE_INVALIDSTATS	./h/hf.h	65;"	d
HFE_OK	./h/hf.h	42;"	d
HFE_OPERATOR	./h/hf.h	58;"	d
HFE_PAGE	./h/hf.h	62;"	d
HFE_PF	./h/hf.h	43;"	d
HFE_RECSIZE	./h/hf.h	50;"	d
HFE_SCANNOTOPEN	./h/hf.h	54;"	d
HFE_SCANOPEN	./h/hf.h	52;"	d
HFE_SD	./h/hf.h	47;"	d
HFE_STABFULL	./h/hf.h	45;"	d
HFHeader	./h/hf.h	/^} HFHeader;$/;"	t	typeref:struct:__anon5
HF_FTAB_SIZE	./h/hf.h	6;"	d
HF_NERRORS	./h/hf.h	40;"	d
HT	./bf/bf.c	/^static Hash_Table *HT;$/;"	v	file:
H_add_page	./bf/bf_component.c	/^int H_add_page(Hash_Table *HT, BFpage *add_page) {$/;"	f
H_get_entry	./bf/bf_component.c	/^BFhash_entry* H_get_entry(Hash_Table *HT, int fd, int pagenum) {$/;"	f
H_get_index	./bf/bf_component.c	/^int H_get_index(Hash_Table *HT, int fd, int pagenum) {$/;"	f
H_remove_page	./bf/bf_component.c	/^int H_remove_page(Hash_Table *HT, int fd, int pagenum) {$/;"	f
Hash_Table	./bf/bf_component.h	/^typedef struct Hash_Table {$/;"	s
Hash_Table	./bf/bf_component.h	/^} Hash_Table;$/;"	t	typeref:struct:Hash_Table
Hash_Table_Init	./bf/bf_component.c	/^void Hash_Table_Init(Hash_Table *HT, int hash_size) {$/;"	f
Hash_Table_delete	./bf/bf_component.c	/^void Hash_Table_delete(Hash_Table *HT) { \/* JM_edit *\/$/;"	f
INCDIR	./am/Makefile	/^INCDIR	= ${MINIREL_HOME}\/h$/;"	m
INCDIR	./bf/Makefile	/^INCDIR	= ${MINIREL_HOME}\/h$/;"	m
INCDIR	./fe/Makefile	/^INCDIR	= ${MINIREL_HOME}\/h$/;"	m
INCDIR	./hf/Makefile	/^INCDIR	= ${MINIREL_HOME}\/h$/;"	m
INCDIR	./pf/Makefile	/^INCDIR	= ${MINIREL_HOME}\/h$/;"	m
INCS	./am/Makefile	/^INCS	= $/;"	m
INCS	./bf/Makefile	/^INCS	= $/;"	m
INCS	./fe/Makefile	/^INCS	= $/;"	m
INCS	./hf/Makefile	/^INCS	= $/;"	m
INCS	./pf/Makefile	/^INCS	= $/;"	m
INDEXED	./h/catalog.h	61;"	d
INT_SIZE	./h/fe.h	159;"	d
INT_TYPE	./h/minirel.h	18;"	d
LE_OP	./h/minirel.h	28;"	d
LIB	./am/Makefile	/^LIB	= am$/;"	m
LIB	./bf/Makefile	/^LIB	= bf$/;"	m
LIB	./fe/Makefile	/^LIB	= fe$/;"	m
LIB	./hf/Makefile	/^LIB	= hf$/;"	m
LIB	./pf/Makefile	/^LIB	= pf$/;"	m
LIBS	./am/Makefile	/^LIBS	= lib${LIB}.a ..\/pf\/libpf.a ..\/hf\/libhf.a ..\/bf\/libbf.a$/;"	m
LIBS	./bf/Makefile	/^LIBS	= lib${LIB}.a$/;"	m
LIBS	./fe/Makefile	/^LIBS	= lib${LIB}.a ..\/am\/libam.a ..\/hf\/libhf.a ..\/pf\/libpf.a ..\/bf\/libbf.a$/;"	m
LIBS	./hf/Makefile	/^LIBS	= lib${LIB}.a ..\/pf\/libpf.a ..\/bf\/libbf.a$/;"	m
LIBS	./pf/Makefile	/^LIBS	= lib${LIB}.a ..\/bf\/libbf.a$/;"	m
LRU	./bf/bf.c	/^static LRU_List *LRU;$/;"	v	file:
LRU_List	./bf/bf_component.h	/^typedef struct LRU_List {     \/* LRU's head is the most recent & tail the oldest *\/$/;"	s
LRU_List	./bf/bf_component.h	/^} LRU_List;$/;"	t	typeref:struct:LRU_List
LRU_List_Init	./bf/bf_component.c	/^void LRU_List_Init(LRU_List *LRU) {$/;"	f
LRU_delete	./bf/bf_component.c	/^void LRU_delete(LRU_List *LRU) { \/* JM_edit *\/$/;"	f
LT_OP	./h/minirel.h	26;"	d
L_add_page	./bf/bf_component.c	/^int L_add_page(LRU_List *LRU, BFpage *bfpage) {$/;"	f
L_detach_page	./bf/bf_component.c	/^BFpage* L_detach_page(LRU_List *LRU, BFpage *bfpage) {$/;"	f
L_find_victim	./bf/bf_component.c	/^BFpage* L_find_victim(LRU_List *LRU) {$/;"	f
L_make_head	./bf/bf_component.c	/^int L_make_head(LRU_List *LRU, BFpage *target_page) {$/;"	f
L_show	./bf/bf_component.c	/^void L_show(LRU_List *LRU) {$/;"	f
MAXISCANS	./h/am.h	7;"	d
MAXNAME	./h/catalog.h	22;"	d
MAXNAME	./h/fe.h	11;"	d
MAXOPENFILES	./h/minirel.h	36;"	d
MAXSCANS	./h/hf.h	7;"	d
MAXSTRINGLEN	./h/fe.h	17;"	d
MAXSTRLEN	./fe/studprofdb-schema.h	1;"	d
MINIREL_HOME	./bf/Makefile	/^MINIREL_HOME = \/home\/huitaek\/Class\/database\/Database\/Database-minirel$/;"	m
NE_OP	./h/minirel.h	30;"	d
NTYPES	./h/minirel.h	17;"	d
NUMBER	./hf/hftest.c	11;"	d	file:
NumFrPgFile	./h/hf.h	/^    int NumFrPgFile;             \/* Number of free pages in the file *\/ $/;"	m	struct:__anon5
NumPg	./h/hf.h	/^    int NumPg;                   \/* Number of pages in file *\/$/;"	m	struct:__anon5
OBJS	./am/Makefile	/^OBJS	= ${SRCS:.c=.o}$/;"	m
OBJS	./bf/Makefile	/^OBJS	= ${SRCS:.c=.o}$/;"	m
OBJS	./fe/Makefile	/^OBJS	= ${SRCS:.c=.o}$/;"	m
OBJS	./hf/Makefile	/^OBJS	= ${SRCS:.c=.o}$/;"	m
OBJS	./pf/Makefile	/^OBJS	= ${SRCS:.c=.o}$/;"	m
PAGENUM	./h/hf.h	76;"	d
PAGE_SIZE	./h/minirel.h	39;"	d
PFE_EOF	./h/pf.h	46;"	d
PFE_FD	./h/pf.h	45;"	d
PFE_FILENOTOPEN	./h/pf.h	48;"	d
PFE_FILEOPEN	./h/pf.h	47;"	d
PFE_FTABFULL	./h/pf.h	44;"	d
PFE_HDRREAD	./h/pf.h	49;"	d
PFE_HDRWRITE	./h/pf.h	50;"	d
PFE_INVALIDPAGE	./h/pf.h	43;"	d
PFE_MSGERR	./h/pf.h	53;"	d
PFE_NOUSERS	./h/pf.h	52;"	d
PFE_OK	./h/pf.h	42;"	d
PFE_PAGEFREE	./h/pf.h	51;"	d
PFE_UNIX	./h/pf.h	58;"	d
PF_AllocPage	./pf/pf.c	/^int PF_AllocPage (int fd, int *pagenum, char **pagebuf){$/;"	f
PF_AllocPage	./pf/ref.c	/^int PF_AllocPage (int fd, int *pagenum, char **pagebuf) {$/;"	f
PF_CloseFile	./pf/pf.c	/^int PF_CloseFile(int fd)$/;"	f
PF_CloseFile	./pf/ref.c	/^int PF_CloseFile (int fd) {$/;"	f
PF_CreateFile	./pf/pf.c	/^int PF_CreateFile(const char *filename)$/;"	f
PF_CreateFile	./pf/ref.c	/^int PF_CreateFile(char *filename){$/;"	f
PF_DestroyFile	./pf/pf.c	/^int PF_DestroyFile(const char *filename)$/;"	f
PF_DestroyFile	./pf/ref.c	/^int PF_DestroyFile (char *filename) {$/;"	f
PF_DirtyPage	./pf/pf.c	/^int  PF_DirtyPage	(int fd, int pagenum){$/;"	f
PF_DirtyPage	./pf/ref.c	/^int PF_DirtyPage(int fd, int pageNum) {$/;"	f
PF_ErrorHandler	./pf/ref.c	/^void PF_ErrorHandler(int error){$/;"	f
PF_FTAB_SIZE	./h/pf.h	11;"	d
PF_GetFirstPage	./pf/pf.c	/^int  PF_GetFirstPage (int fd, int *pagenum, char **pagebuf){$/;"	f
PF_GetFirstPage	./pf/ref.c	/^int PF_GetFirstPage (int fd, int *pageNum, char **pagebuf){$/;"	f
PF_GetNextPage	./pf/pf.c	/^int  PF_GetNextPage	(int fd, int *pagenum, char **pagebuf){$/;"	f
PF_GetNextPage	./pf/ref.c	/^int PF_GetNextPage (int fd, int *pageNum, char **pagebuf){$/;"	f
PF_GetThisPage	./pf/pf.c	/^int  PF_GetThisPage	(int fd, int pagenum, char **pagebuf){$/;"	f
PF_GetThisPage	./pf/ref.c	/^int PF_GetThisPage (int fd, int pageNum, char **pagebuf){$/;"	f
PF_Init	./pf/pf.c	/^void PF_Init(void)$/;"	f
PF_Init	./pf/ref.c	/^void PF_Init(void){$/;"	f
PF_NERRORS	./h/pf.h	40;"	d
PF_OpenFile	./pf/pf.c	/^int PF_OpenFile(const char *filename)$/;"	f
PF_OpenFile	./pf/ref.c	/^int PF_OpenFile (char *filename) {$/;"	f
PF_PAGE_SIZE	./h/minirel.h	40;"	d
PF_PAGE_SIZE	./h/pf.h	17;"	d
PF_PrintError	./pf/pf.c	/^void PF_PrintError(const char *errString)$/;"	f
PF_PrintError	./pf/ref.c	/^void PF_PrintError (char* error){$/;"	f
PF_PrintTable	./pf/ref.c	/^void PF_PrintTable(void){$/;"	f
PF_UnpinPage	./pf/pf.c	/^int  PF_UnpinPage	(int fd, int pagenum, int dirty){$/;"	f
PF_UnpinPage	./pf/ref.c	/^int PF_UnpinPage(int fd, int pageNum, int dirty) {	$/;"	f
PFftab	./pf/ref.c	/^PFftab_ele *PFftab; $/;"	v
PFftab_ele	./pf/pf.c	/^typedef struct PFftab_ele {$/;"	s	file:
PFftab_ele	./pf/pf.c	/^} PFftab_ele;$/;"	t	typeref:struct:PFftab_ele	file:
PFftab_length	./pf/pf.c	/^size_t PFftab_length;$/;"	v
PFftab_length	./pf/ref.c	/^size_t PFftab_length;$/;"	v
PFftable	./pf/pf.c	/^PFftab_ele *PFftable; $/;"	v
PFhdr_str	./pf/pf.c	/^typedef struct PFhdr_str {$/;"	s	file:
PFhdr_str	./pf/pf.c	/^} PFhdr_str;$/;"	t	typeref:struct:PFhdr_str	file:
PFpage	./h/minirel.h	/^typedef struct PFpage {$/;"	s
PFpage	./h/minirel.h	/^} PFpage;$/;"	t	typeref:struct:PFpage
PROFREL	./fe/fetest-ddl.c	19;"	d	file:
PROFREL	./fe/fetest-dml.c	19;"	d	file:
PROF_FILE	./fe/studprofdb-schema.h	14;"	d
PROF_LOADFILE	./fe/fetest-ddl.c	23;"	d	file:
PROF_NUM	./fe/studprofdb-schema.h	15;"	d
PROF_NUM_ATTRS	./fe/studprofdb-schema.h	16;"	d
REAL_SIZE	./h/fe.h	160;"	d
REAL_TYPE	./h/minirel.h	19;"	d
RECID	./h/minirel.h	/^} RECID;$/;"	t	typeref:struct:_hf_record_identification
RECNUM	./h/hf.h	77;"	d
RECORDVAL	./hf/hftest.c	12;"	d	file:
RECSIZE	./hf/hftest.c	9;"	d	file:
RELCATNAME	./h/catalog.h	17;"	d
RELCAT_NATTRS	./h/catalog.h	35;"	d
RELDESCSIZE	./h/catalog.h	34;"	d
RELDESCTYPE	./h/catalog.h	/^} RELDESCTYPE;$/;"	t	typeref:struct:_relation_desc
REL_ATTR	./h/fe.h	/^} REL_ATTR;$/;"	t	typeref:struct:__anon3
RecPage	./h/hf.h	/^    int RecPage;                 \/* Number of records per page *\/$/;"	m	struct:__anon5
RecSize	./h/hf.h	/^    int RecSize;                 \/* Record size *\/$/;"	m	struct:__anon5
SRCS	./am/Makefile	/^SRCS	= $/;"	m
SRCS	./bf/Makefile	/^SRCS	= bf.c bf_component.c$/;"	m
SRCS	./fe/Makefile	/^SRCS	= $/;"	m
SRCS	./hf/Makefile	/^SRCS	= $/;"	m
SRCS	./pf/Makefile	/^SRCS	= $/;"	m
STRING_TYPE	./h/minirel.h	20;"	d
STRSIZE	./am/amtest.c	20;"	d	file:
STRSIZE	./hf/hftest.c	10;"	d	file:
STUDREL	./fe/fetest-ddl.c	18;"	d	file:
STUDREL	./fe/fetest-dml.c	18;"	d	file:
STUD_FILE	./fe/studprofdb-schema.h	3;"	d
STUD_LOADFILE	./fe/fetest-ddl.c	22;"	d	file:
STUD_NUM	./fe/studprofdb-schema.h	4;"	d
STUD_NUM_ATTRS	./fe/studprofdb-schema.h	5;"	d
TESTDB	./fe/fetest-ddl.c	17;"	d	file:
TESTDB	./fe/fetest-dml.c	17;"	d	file:
TESTS	./am/Makefile	/^TESTS	= amtest.c$/;"	m
TESTS	./bf/Makefile	/^TESTS	= bftest.c$/;"	m
TESTS	./fe/Makefile	/^TESTS	= fetest-ddl.c fetest-dml.c$/;"	m
TESTS	./hf/Makefile	/^TESTS	= hftest.c$/;"	m
TESTS	./pf/Makefile	/^TESTS	= pftest.c$/;"	m
TOTALTESTS	./am/amtest.c	21;"	d	file:
TRUE	./h/minirel.h	/^typedef enum { FALSE = 0, TRUE } bool_t;$/;"	e	enum:__anon1
TYPE_TYPE	./h/catalog.h	72;"	d
__AM_H__	./h/am.h	2;"	d
__BF_COMPONENT_H	./bf/bf_component.h	2;"	d
__BF_H__	./h/bf.h	2;"	d
__CATALOG_H__	./h/catalog.h	6;"	d
__FE_H__	./h/fe.h	2;"	d
__HF_H__	./h/hf.h	2;"	d
__MINIREL_H__	./h/minirel.h	2;"	d
__PF_H__	./h/pf.h	2;"	d
_attribute_desc	./h/catalog.h	/^typedef struct _attribute_desc {$/;"	s
_buffer_request_control	./h/minirel.h	/^typedef struct _buffer_request_control {$/;"	s
_hf_record_identification	./h/minirel.h	/^typedef  struct _hf_record_identification {$/;"	s
_relation_desc	./h/catalog.h	/^typedef struct _relation_desc {$/;"	s
advisor	./fe/studprofdb-schema.h	/^	int	advisor;$/;"	m	struct:student_rec
age	./fe/studprofdb-schema.h	/^	int	age;$/;"	m	struct:student_rec
amtest1	./am/amtest.c	/^void amtest1()$/;"	f
amtest2	./am/amtest.c	/^void amtest2()$/;"	f
amtest3	./am/amtest.c	/^void amtest3()$/;"	f
attrCatOffset	./h/catalog.h	53;"	d
attrLen	./h/fe.h	/^    int attrLen;	\/* length of attribute	*\/$/;"	m	struct:__anon2
attrName	./h/fe.h	/^    char *attrName;	\/* attribute name	*\/$/;"	m	struct:__anon3
attrName	./h/fe.h	/^    char *attrName;	\/* attribute name	*\/$/;"	m	struct:__anon4
attrName	./h/fe.h	/^    char *attrName;	\/* relation name	*\/$/;"	m	struct:__anon2
attrType	./h/fe.h	/^    int attrType;	\/* type of attribute	*\/$/;"	m	struct:__anon2
attrcnt	./h/catalog.h	/^    int  attrcnt;		\/* number of attributes			*\/$/;"	m	struct:_relation_desc
attrlen	./h/catalog.h	/^    int  attrlen;		\/* attribute length			*\/$/;"	m	struct:_attribute_desc
attrname	./h/catalog.h	/^    char attrname[MAXNAME];	\/* attribute name			*\/$/;"	m	struct:_attribute_desc
attrno	./h/catalog.h	/^    int  attrno;		\/* attr number (used in index name)	*\/$/;"	m	struct:_attribute_desc
attrtype	./h/catalog.h	/^    int  attrtype;		\/* attribute type			*\/$/;"	m	struct:_attribute_desc
bfpage_clean_val	./bf/bf_component.c	/^void bfpage_clean_val(BFpage *bfpage) {$/;"	f
bool_t	./h/minirel.h	/^typedef enum { FALSE = 0, TRUE } bool_t;$/;"	t	typeref:enum:__anon1
bpage	./bf/bf_component.h	/^  struct BFpage *bpage;               \/* ptr to buffer holding this page *\/$/;"	m	struct:BFhash_entry	typeref:struct:BFhash_entry::BFpage
breq	./bf/bftest.c	/^static BFreq	breq;$/;"	v	file:
cleanup	./am/amtest.c	/^void cleanup(void)$/;"	f
cleanup	./fe/fetest-ddl.c	/^void cleanup(void)$/;"	f
cleanup	./fe/fetest-dml.c	/^void cleanup(void)$/;"	f
count	./bf/bf_component.h	/^  short          count;       \/* pin count associated with the page      *\/$/;"	m	struct:BFpage
create_professor	./fe/fetest-ddl.c	/^void create_professor()$/;"	f
create_professor	./fe/fetest-dml.c	/^void create_professor()$/;"	f
create_student	./fe/fetest-ddl.c	/^void create_student()$/;"	f
create_student	./fe/fetest-dml.c	/^void create_student()$/;"	f
delete_professor	./fe/fetest-dml.c	/^void delete_professor()$/;"	f
delete_student	./fe/fetest-dml.c	/^void delete_student()$/;"	f
destroy_table	./fe/fetest-ddl.c	/^void destroy_table(const char *relname)$/;"	f
dirty	./bf/bf_component.h	/^  bool_t         dirty;       \/* TRUE if page is dirty                   *\/$/;"	m	struct:BFpage
dirty	./h/minirel.h	/^    bool_t      dirty;                  \/* TRUE if page is dirty *\/$/;"	m	struct:_buffer_request_control
dropindex_professor	./fe/fetest-ddl.c	/^void dropindex_professor()$/;"	f
dropindex_student	./fe/fetest-ddl.c	/^void dropindex_student()$/;"	f
faculty_rec	./fe/studprofdb-schema.h	/^typedef struct faculty_rec {$/;"	s
fd	./bf/bf_component.h	/^  int            fd;          \/* PF file descriptor of this page         *\/$/;"	m	struct:BFpage
fd	./bf/bf_component.h	/^  int fd;                             \/* file descriptor                 *\/$/;"	m	struct:BFhash_entry
fd	./h/minirel.h	/^    int         fd;                     \/* PF file descriptor *\/$/;"	m	struct:_buffer_request_control
float_val	./hf/hftest.c	/^   float float_val;$/;"	m	struct:rec_struct	file:
fname	./pf/pf.c	/^	char		*fname;		\/* file name				*\/$/;"	m	struct:PFftab_ele	file:
fpage	./bf/bf_component.h	/^  PFpage         fpage;       \/* page data from the file                 *\/$/;"	m	struct:BFpage
gpa	./fe/studprofdb-schema.h	/^	float	gpa;$/;"	m	struct:student_rec
handle_error	./bf/bf.c	11;"	d	file:
handle_error	./bf/bf_component.c	8;"	d	file:
hash_entries	./bf/bf_component.h	/^  BFhash_entry  **hash_entries;$/;"	m	struct:Hash_Table
head	./bf/bf_component.h	/^  BFpage        *head;        \/* head|most recent page *\/$/;"	m	struct:LRU_List
head	./bf/bf_component.h	/^  BFpage        *head;        \/* points to head page of the Free list *\/$/;"	m	struct:Free_List
header	./bf/bftest.c	/^static char	header[PAGE_SIZE];$/;"	v	file:
hftest1	./hf/hftest.c	/^void hftest1()$/;"	f
hftest2	./hf/hftest.c	/^void hftest2()$/;"	f
hftest3	./hf/hftest.c	/^void hftest3() $/;"	f
index_professor	./fe/fetest-ddl.c	/^void index_professor()$/;"	f
index_professor	./fe/fetest-dml.c	/^void index_professor()$/;"	f
index_student	./fe/fetest-ddl.c	/^void index_student()$/;"	f
index_student	./fe/fetest-dml.c	/^void index_student()$/;"	f
indexcnt	./h/catalog.h	/^    int  indexcnt;		\/* number of indexed attributes		*\/$/;"	m	struct:_relation_desc
indexed	./h/catalog.h	/^    bool_t  indexed;		\/* if the field is indexed or not       *\/$/;"	m	struct:_attribute_desc
inode	./pf/pf.c	/^	ino_t		inode;		\/* inode number of the file 		*\/$/;"	m	struct:PFftab_ele	file:
insert_professor	./fe/fetest-dml.c	/^void insert_professor()$/;"	f
insert_struc_recs	./hf/hftest.c	/^int insert_struc_recs(const char *filename)$/;"	f
insert_student	./fe/fetest-dml.c	/^void insert_student()$/;"	f
int_val	./hf/hftest.c	/^   int int_val;$/;"	m	struct:rec_struct	file:
join_student_prof	./fe/fetest-dml.c	/^void join_student_prof(char *resRel)$/;"	f
load_professor	./fe/fetest-ddl.c	/^void load_professor()$/;"	f
load_student	./fe/fetest-ddl.c	/^void load_student()$/;"	f
main	./am/amtest.c	/^int main(int argc, char *argv[])$/;"	f
main	./bf/bftest.c	/^int main()$/;"	f
main	./fe/fetest-ddl.c	/^int main(int argc, char *argv[])$/;"	f
main	./fe/fetest-dml.c	/^int main(int argc, char *argv[])$/;"	f
main	./hf/hftest.c	/^int main()$/;"	f
main	./pf/pftest.c	/^int main()$/;"	f
make_attrDesc	./fe/fetest-ddl.c	/^void make_attrDesc(ATTR_DESCR *attr, const char *name, char type, int len)$/;"	f
make_attrDesc	./fe/fetest-dml.c	/^void make_attrDesc(ATTR_DESCR *attr, const char *name, char type, int len)$/;"	f
make_attrVal	./fe/fetest-dml.c	/^void make_attrVal(ATTR_VAL *aval, const char *name, char type, int len)$/;"	f
make_relAttr	./fe/fetest-dml.c	/^void make_relAttr(REL_ATTR *ra, const char *relname, const char *attrname)$/;"	f
max_bfpage	./bf/bf_component.h	/^  int           max_bfpage;   \/* maximum number of free pages *\/$/;"	m	struct:Free_List
nextentry	./bf/bf_component.h	/^  struct BFhash_entry *nextentry;     \/* next hash table element or NULL *\/$/;"	m	struct:BFhash_entry	typeref:struct:BFhash_entry::BFhash_entry
nextpage	./bf/bf_component.h	/^  struct BFpage  *nextpage;   \/* next in the linked list of buffer pages *\/$/;"	m	struct:BFpage	typeref:struct:BFpage::BFpage
numpages	./pf/pf.c	/^	int 	numpages;	\/* number of pages in the file *\/$/;"	m	struct:PFhdr_str	file:
office	./fe/studprofdb-schema.h	/^	int	office;$/;"	m	struct:faculty_rec
offset	./h/catalog.h	/^    int  offset;		\/* attribute offset in tuple		*\/$/;"	m	struct:_attribute_desc
offsetof	./hf/hftest.c	17;"	d	file:
pagebuf	./h/minirel.h	/^    char pagebuf[PAGE_SIZE];		\/* actual page data             *\/$/;"	m	struct:PFpage
pagenum	./bf/bf_component.h	/^  int            pagenum;     \/* page number of this page                *\/$/;"	m	struct:BFpage
pagenum	./bf/bf_component.h	/^  int pagenum;                        \/* page number                     *\/$/;"	m	struct:BFhash_entry
pagenum	./h/minirel.h	/^	int	pagenum;$/;"	m	struct:_hf_record_identification
pagenum	./h/minirel.h	/^    int         pagenum;                \/* Page number in the file *\/$/;"	m	struct:_buffer_request_control
pid	./fe/studprofdb-schema.h	/^	int	pid;$/;"	m	struct:faculty_rec
pname	./fe/studprofdb-schema.h	/^	char	pname[MAXSTRLEN];$/;"	m	struct:faculty_rec
preventry	./bf/bf_component.h	/^  struct BFhash_entry *preventry;     \/* prev hash table element or NULL *\/$/;"	m	struct:BFhash_entry	typeref:struct:BFhash_entry::BFhash_entry
prevpage	./bf/bf_component.h	/^  struct BFpage  *prevpage;   \/* prev in the linked list of buffer pages *\/$/;"	m	struct:BFpage	typeref:struct:BFpage::BFpage
primattr	./h/catalog.h	/^    char primattr[MAXNAME];	\/* name of primary attribute		*\/$/;"	m	struct:_relation_desc
printfile	./bf/bftest.c	/^void printfile(const char *fname)$/;"	f
printfile	./pf/pftest.c	/^void printfile(int fd)$/;"	f
professor	./fe/studprofdb-schema.h	/^} professor;$/;"	t	typeref:struct:faculty_rec
read_string_recs	./hf/hftest.c	/^int read_string_recs(const char *filename)$/;"	f
read_struc_recs	./hf/hftest.c	/^int read_struc_recs(const char *filename)$/;"	f
readfile	./bf/bftest.c	/^void readfile(const char *fname)$/;"	f
readfile	./pf/pftest.c	/^void readfile(const char *fname)$/;"	f
real	./h/minirel.h	/^typedef float  real;$/;"	t
rec_struct	./hf/hftest.c	/^struct rec_struct$/;"	s	file:
recnum	./h/minirel.h	/^	int	recnum;$/;"	m	struct:_hf_record_identification
relCatOffset	./h/catalog.h	36;"	d
relName	./h/fe.h	/^    char *relName;	\/* relation name	*\/$/;"	m	struct:__anon3
relname	./h/catalog.h	/^    char relname[MAXNAME];	\/* relation name			*\/$/;"	m	struct:_attribute_desc
relname	./h/catalog.h	/^    char relname[MAXNAME];	\/* relation name			*\/$/;"	m	struct:_relation_desc
relwid	./h/catalog.h	/^    int  relwid;		\/* tuple width (in bytes)		*\/$/;"	m	struct:_relation_desc
select_professor	./fe/fetest-dml.c	/^void select_professor()$/;"	f
select_student	./fe/fetest-dml.c	/^void select_student()$/;"	f
show_catalogs	./fe/fetest-ddl.c	/^void show_catalogs()$/;"	f
show_catalogs	./fe/fetest-dml.c	/^void show_catalogs()$/;"	f
show_table	./fe/fetest-ddl.c	/^void show_table(const char *relname)$/;"	f
show_table	./fe/fetest-dml.c	/^void show_table(const char *relname)$/;"	f
sid	./fe/studprofdb-schema.h	/^	int	sid;$/;"	m	struct:student_rec
size	./bf/bf_component.h	/^  int           size;         \/* total number of pages in LRU *\/$/;"	m	struct:LRU_List
size	./bf/bf_component.h	/^  int           size;         \/* total number of pages in the list *\/$/;"	m	struct:Free_List
size	./bf/bf_component.h	/^  int           size;$/;"	m	struct:Hash_Table
sname	./fe/studprofdb-schema.h	/^	char	sname[MAXSTRLEN];$/;"	m	struct:student_rec
string_val	./hf/hftest.c	/^   char string_val[STRSIZE];$/;"	m	struct:rec_struct	file:
student	./fe/studprofdb-schema.h	/^} student;$/;"	t	typeref:struct:student_rec
student_rec	./fe/studprofdb-schema.h	/^typedef struct student_rec {$/;"	s
tail	./bf/bf_component.h	/^  BFpage        *tail;        \/* tail|most old page *\/$/;"	m	struct:LRU_List
testbf1	./bf/bftest.c	/^void testbf1(void)$/;"	f
testpf1	./pf/pftest.c	/^void testpf1(void)$/;"	f
tests	./am/amtest.c	/^void (*tests[])() = {amtest1, amtest2, amtest3, cleanup};$/;"	v
unixfd	./bf/bf_component.h	/^  int            unixfd;      \/* Unix file descriptor of this page       *\/$/;"	m	struct:BFpage
unixfd	./h/minirel.h	/^    int         unixfd;                 \/* Unix file descriptor *\/$/;"	m	struct:_buffer_request_control
unixfd	./pf/pf.c	/^	int 		unixfd;		\/* Unix file descriptor			*\/$/;"	m	struct:PFftab_ele	file:
valLength	./h/fe.h	/^    int valLength;	\/* length if type = STRING_TYPE *\/$/;"	m	struct:__anon4
valType	./h/fe.h	/^    int valType;	\/* type of value	*\/$/;"	m	struct:__anon4
valid	./pf/pf.c	/^	bool_t		valid;		\/* set to TRUE when a file is open 	*\/$/;"	m	struct:PFftab_ele	file:
value	./h/fe.h	/^    char *value;	\/* value for attribute	*\/$/;"	m	struct:__anon4
writeback	./bf/bf.c	/^static writeback(BFpage* victim) {$/;"	f	file:
writefile	./bf/bftest.c	/^void writefile(const char *fname)$/;"	f
writefile	./pf/pftest.c	/^void writefile(const char *fname)$/;"	f
